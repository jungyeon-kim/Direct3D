/*
	기저 벡터:		축에 대한 단위벡터
	선형 변환:		한 벡터공간을 다른 벡터공간으로 변환하는 것
	위치 변환:		한 점을 다른 점으로 변환하는 것
	아핀 공간:		점과 벡터로 이루어진 공간
	아핀 변환:		선형 변환 + 위치 변환
	동차좌표(w):		벡터, 점 둘다를 표현하기 위해 사용 (일반적으로 0은 벡터, 1은 점이라 가정)

	AABB:			축 정렬 바운딩 박스		(객체가 회전해도 그대로)
	OOBB:			객체 정렬 바운딩 박스		(객체가 회전하면 같이 회전)

	종횡비:			가로 / 세로 (640x480의 종횡비는 1.3333~)
	클리핑:			뷰 프로스텀에 포함되지 않으면 렌더링하지 않는 것
*/

/*
	DirectX:	왼손 좌표계, 행우선 행렬		(좌 -> 우 연산)
	OpenGL:		오른손 좌표계, 열우선 행렬	(우 -> 좌 연산)

	행렬 A가 직교행렬이다. -> 행렬 A의 각 행들이 직교한다. -> A의 역행렬 == A의 전치행렬
*/

/*
	변환 파이프라인:	월드 변환 -> 카메라(뷰) 변환 -> 투영 변환 -> 스크린 변환

	카메라(뷰) 변환:
	카메라는 연산이 자주 일어나고 방향 혹은 위치만 필요할 수 있음. 따라서, 하나의 행렬이 아닌 네개의 벡터로 선언.
	-> 전부 월드좌표의 벡터임. 왜? 카메라좌표로 표현하는 것은 항상 고정되어있으니 의미가없음.
	카메라 회전은 카메라가 회전하는게 아니라 오브젝트들이 회전하는 것. (카메라 회전방향의 반대로)
	부동소수점 문제때문에 회전시 축이 어긋날 수 있음. -> 외적을 이용해 다시 세 축이 직교하도록 만들어야함.

	투영 변환:
	투영 변환을 하면 -1 <= x, y <= 1 / 0 <= z <= 1
	투영 변환을 쓰는 이유는 FOV를 90도인 것처럼 보이기 위해, 화면 종횡비를 맞춰주기 위해서임
	FOV를 90도로 안쓰고 60이나 45를 쓰는 이유는 FOV가 클수록 보이는 정점들이 많아 렌더링 오버헤드가 발생하기 떄문
	또한, 절두체의 원평면까지의 거리가 클수록 렌더링 오버헤드 발생
*/